Scripts to evaluate/test/benchmark SKIVA's AES
===

### Code generation

 - `compile.pl`: compiles various variants of AES: with 1, 2, and 4
   shares, 1, 2 and 4 redundant slices, with and without pipelining,
   with and without custom instructions... It puts the generated
   binaries in `../bin`.
   
 - `gen_asm.pl`: generates the assembly codes corresponding to all
    combinations of Rs (spatial redundancy; 1, 2 or 4), Rt
    (pipelining/temporal redundancy; 1 or 2) and D (number of shares
    for masking; 1, 2 or 4). Those assembly files could serve two
    purposes: first, they can be manually inspected by someone wanting
    to make sure that our implementations are correct. Or, they can be
    used by someone who wants to use our AES and doesn't want to rely
    on our C code (for instance, because the macros make compilation a
    bit more complex, or because C is slighly impredictible depending
    on the compilers...).
 
### Performance evaluation

Note that most of those scripts rely on `compile.pl` to have ran
before and produced the binaries they are evaluating.
   
 - `code_sizes.pl`: compiles AES with various settings for masking,
   and redundancy, and measures the size of the resulting
   binaries. Results are put in `../results/code_sizes.{txt,tex}`.
   
 - `gen_bin_list.pl`: generates a list of binary to run for the
   performance evaluation in `../bin/bin_list.txt`.
   
 - `analyze_results_perfs.pl`: runs the binary compiled with
   `compile.pl` and listed with `gen_bin_list.pl`, and collects the
   performance results inside `../results/general_perfs.tex`. Note
   that in order to work, `grmon` must be running, as well as a
   program like `minicom` to capture the output of the board. For
   instance, in a terminal, run:
   
   ```
   sudo grmon -gdb -uart /dev/ttyUSB0
   ```

    And in another one, run:
    
    ```
    sudo minicom -b 38400 --device /dev/ttyUSB1 -C out_perfs.txt
    ```

    Then edit `analyze_results_perfs.pl` line 14 to put the path to
    `out_perfs.txt` if it is not in the current folder.
    
  - `compute_ratios.pl`: computes the speedup offered by the custom
    instructions. It uses the binaries produced by `compile.pl`. It
    outputs its results in `results/speedups_custom.tex`. Note that
    this time again, `grmon` and `minicom` must be running, and you
    might need to edit line 14 (see `analyze_results_perfs.pl`'s
    description above).
    
  - `eval_rand.pl`: for each combination of Rs (spatial redundancy; 1,
    2 or 4), Rt (pipelining/temporal redundancy; 1 or 2) and D (number
    of shares for masking; 1, 2 or 4), computes at which rate the RNG
    must produce random bits in order not to slow the computation
    down. Note that this script recompiles the binary it
    needs. `grmon` and `minicom` must be running, and you might need
    to edit line 16 (see `analyze_results_perfs.pl`'s description
    above).

  - `run_eval.pl`: runs all of the aforementioned scripts, in that
    order. In a nutshell, the performance evaluation can be run in one
    command by running `run_eval.pl`. Note that `grmon` and `minicom`
    must be running (see `analyze_results_perfs.pl`'s description
    above).
    

### Correctness

  - `run_checks.pl`: compiles all combinations of Rs (spatial
    redundancy; 1, 2 or 4), Rt (pipelining/temporal redundancy; 1 or
    2) and D (number of shares for masking; 1, 2 or 4). If supplied
    with the argument `X86`, it compiles for x86 (ie, it doesn't use
    custom instructions, and uses gcc instead of
    sparc-gaisler-elf-gcc). If `run` is also supplied, it runs the
    generated binaries. This should output, for each binary, the
    sentence "AES seems correct", as well as its performance.


### Fault-injection simulation

  - `gen_aes_inputs.pl`: generates a random 512-bytes plaintext (32
    times 16 bytes), encrypts it with AES in ECB (using the module
    `Crypt::Mode::ECB` from Perl's CPAN repositories), and outputs
    both the plaintext and the ciphertext in `../aes/faults_input.h`,
    which is meant to be included in the fault main.
    
  - `test_faults.pl`: simulates fault-injection on our implementations
    by using `gdb` to skip instructions. It is hardcoded to use 1
    share and 4 redundant slices, but it's fairly straight-forward
    search/replace all occurences of `TI` and `FD` to change those
    values. Note that once again, `grmon` and `minicom` must be
    running (see `analyze_results_perfs.pl`'s description above). It
    outputs the results in `results/faults_res_${bin_name}.txt` when
    `bin_name` is the name of the implementation it's
    evaluating. Those output files can then be passed to
    `analyze_faults_files.pl` which extracts more readable data out of
    them.
    
  - `analyze_faults_files.pl` takes as input a file generated by
    `test_faults.pl` and synthesizes its content: how many faults
    impacted or not the results, how many were detected/undetected,
    how many were detected, and how many cause AES to crash. It
    outputs to stdout.
